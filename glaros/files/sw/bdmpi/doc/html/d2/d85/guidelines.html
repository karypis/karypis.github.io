<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>BDMPI - Big Data Message Passing Interface: Guidelines for Developing Efficient BDMPI Programs</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BDMPI - Big Data Message Passing Interface
   &#160;<span id="projectnumber">Release 0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d2/d85/guidelines.html','../../');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Guidelines for Developing Efficient BDMPI Programs </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#g_collective">Use collective communication operations</a></li>
<li class="level1"><a href="#g_group">Group blocking communication operations together</a></li>
<li class="level1"><a href="#g_scratch">Freeing scratch memory</a></li>
<li class="level1"><a href="#g_mblocks">Structure memory allocations in terms of active blocks</a></li>
</ul>
</div>
<div class="textblock"><p>In this section we provide some guidelines for developing parallel MPI programs that leverage BDMPI's execution and memory model in order to achieve good out-of-core execution.</p>
<h1><a class="anchor" id="g_collective"></a>
Use collective communication operations</h1>
<p>BDMPI's implementation of MPI's collective communication operations has been optimized so that a process becomes runnable only when all the data that it requires is locally available. As a result, when it is scheduled for execution it will proceed to get any data that it may require and resume execution without needing to block for the same collective operation. This approach minimizes the time spent in saving/restoring to/from disk the active parts of the processes' address space, resulting in fast out-of-core execution. For this reason, the application should try to structure its communication patterns so that it uses the collective communication operations.</p>
<h1><a class="anchor" id="g_group"></a>
Group blocking communication operations together</h1>
<p>When a running processes is blocked due to a blocking MPI operation, the part of the address space that it accessed since the last time it was scheduled will most likely be unmapped from physical memory. When the process' blocking condition is lifted (e.g., received the data that it was waiting for) and is scheduled for execution, it will load the parts of the address space associated with the computations that it will perform until the next time it blocks. Note that even if a process requires to access the same parts of the address space as in the previous step, because of the earlier unmapping, they still need to be remapped from disk to physical memory.</p>
<p>The cost of these successive unmapping/remapping operations from/to the physical memory can potentially be reduced by restructuring the computations so that if an application needs to perform multiple blocking communication operations, it performs them one-after-the-other with little computations between them. Of course, such restructuring may not always be possible, but if it can be done, it will lead to considerable performance improvements.</p>
<h1><a class="anchor" id="g_scratch"></a>
Freeing scratch memory</h1>
<p>If a process, after returning from a blocking communication operation, proceeds to overwrite some of the memory that it allocated previously without first reading from it, then the cost associated with saving them to disk and restoring them from disk is entirely wasted. In such cases, it is better to free that memory prior to performing a blocking communication operation and re-allocating when returning from it. Alternatively, if the allocation is handled by the sbmalloc subsystem (<a class="el" href="../../d1/dfb/intro.html#sbmalloc">Efficient loading &amp; saving of a process's address space</a>), an application can use the <code><a class="el" href="../../d8/dce/group__bdmpisbmalloclist.html#ga8d43b74ab57732deb27bfccb30aa92a1">BDMPI_sbdiscard()</a></code> function (<a class="el" href="../../d8/daa/api.html#bdmpisbmalloc">Storage-backed memory allocations</a>) to inform the sbmalloc subsystem that the memory associated with the provided allocation does not need to be saved and restored during the next block/resume cycle.</p>
<h1><a class="anchor" id="g_mblocks"></a>
Structure memory allocations in terms of active blocks</h1>
<p>As discussed in <a class="el" href="../../d1/dfb/intro.html#sbmalloc">Efficient loading &amp; saving of a process's address space</a>, when the application accesses an address from the memory area that was allocated by the sbmalloc subsystem, BDMPI loads in physical memory the entire allocation that contains that address (i.e., all the memory that was allocated as part of the <code>malloc()</code> call that allocated the memory containing that address). Given this, the application should structure computations and memory allocations so that it is accessing most of the loaded data prior to performing a blocking operation. This will often involve breaking the memory allocations into smaller segments that include just the elements that will be accesses and potentially restructuring the computations so that they exhibit a segment-based spatial locality (i.e., if they access some data in an allocated segment, then they will most likely access all/most of the data in that segment). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Apr 21 2014 14:23:11 for BDMPI - Big Data Message Passing Interface by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
